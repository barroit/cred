#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-3.0-or-later or MIT

# Requires CC TOP GEN BUILD

import atexit
import multiprocessing as mp

from os import devnull, environ as env, path, unlink, getpid
from subprocess import run
from sys import argv, exit
from textwrap import dedent
from platform import system

if len(argv) < 2:
	exit(128)

cc    = env['CC']
top   = env['TOP']
gen   = env['GEN']
build = env['BUILD']

data_name = path.join(top, 'scripts', 'cc-feature.def')

if argv[1] == 'cmake':
	dest_name = path.join(build, 'features.cmake')
elif argv[1] == 'header':
	dest_name = path.join(gen, 'features.h')
else:
	exit(128)

data = open(data_name, 'r')
dest = open(dest_name, 'w')

pid = getpid()
tmp = f'.tmp_{pid}.o'

def echo_pref_cmake():
	dest.write(dedent(f"""\
	# Generated by scripts/cc-feature.py {argv[1]} on {system()}

	"""))

def echo_pref_header():
	dest.write(dedent(f"""\
	/*
	 * Generated by scripts/cc-feature.py {argv[1]} on {system()}
	 */

	#ifdef CONFIG_ENABLE_WCHAR
	# define UNICODE
	#endif
	"""))

def echo_def_cmake(name, ret):
	if ret == 0:
		dest.write(f"\nset({name} 1)\n")
	else:
		dest.write(f"\n# unset({name})\n")

def echo_def_header(name, ret):
	if ret == 0:
		dest.write(f"\n#define {name}\n")
	else:
		dest.write(f"\n/* #undef {name} */\n")

if argv[1] == 'cmake':
	echo_pref = echo_pref_cmake
	echo_def  = echo_def_cmake
else:
	echo_pref = echo_pref_header
	echo_def  = echo_def_header

def rmtmp():
	if path.isfile(tmp):
		unlink(tmp)

atexit.register(rmtmp)

def test_feature(name, prog):
	if prog[0] == '\n':
		cmd = [ cc, '-Werror', '-S', '-x', 'c', '-o', devnull, '-' ]
	else:
		cmd  = [ cc, '-Werror', '-c', '-x', 'c', '-o', tmp, devnull ]
		cmd[1:1] = prog.split()

	res = run(cmd, text=True, input=prog, capture_output=True)

	return (name, res.returncode)

def test_feature_cb(rets):
	echo_pref()

	for name, ret in rets:
		echo_def(name, ret)

# BEGIN	Because Windows fucking sucks.
if __name__ == '__main__':
# END	Because Windows fucking sucks.

	tests = {}

	exec(data.read(), {}, tests)

	pool = mp.Pool(mp.cpu_count() + 1)
	args = [(name, tests[name]) for name in tests]

	pool.starmap_async(test_feature, args, callback = test_feature_cb)

	pool.close()
	pool.join()
